\section{Introduction}

Mobile applications are increasingly interwoven into one another, and applications are able to use a plethora of different applications available to perform a required task. This could be a range of tasks; from viewing a video, processing a payment, sharing content through social networks - the list is virtually endless. Android applications perform this transition from one application to another through a system known as Intents; and an Android application can contain zero or more Intent calls.

Intents are asynchronous messages which provide a facility for performing late runtime binding between the code in different applications, which allows Android components to request functionality from other components of the Android system. Data can be passed to and can be received from a calling Intent, and they can also be used to signal to the Android system that a certain event has occurred. Essentially, an Intent is a passive data structure, holding an abstract description of an action to be performed. 

The code required to initialize Intents, whilst relatively simple in its basic form, is prone to producing errors because of the customizability and extensive optional parameters and uses. An Intent call in a simple case will use just a few lines of code, whereas a fully extended and defined Intent could, through using additional data and specific parameter settings, grow to be quite verbose. 

The goal and motivation of the project is to demonstrate an effective use of Model Driven Development methodology, and evaluate the usefulness of the MDD approach to development. We will do this by developing an Eclipse plug-in that will make implementing Intents in development of Android applications easier for programmers. The plug-in should be a simple, user-friendly GUI driven view that will allow a user to choose an Intent from a list, and generate the code required to call the chosen Intent in the correct format, and place it in the editor window. All available settings for the chosen Intent will be generated, and this will enable the user to modify the generated code to suit their needs quicker and with less errors when compared to manually implementing the code. This demonstration should show how a relatively simple implementation of an MDD project could be extended to cover wider and more complex situations.

An example of a current technology for dealing with Model-to-Text transformation is the open source Acceleo project \cite{acceleo}, development of which started four years ago. The project aims to ease and speed up the writing of tedious framework specific completion code, and is able to create code generators specific to several frameworks, like Android for one.

The Acceleo project provides an abstract syntax for generating concrete code and offers editor features such as highlighting, content assistance and error detection. The code generator works using a template file written in the Acceleo syntax, that reads in a model and generates simple .java files. The code generator can be further customized by specifying blocks in the template that must be implemented by the user post generation.

An additional example of Model-to-Text transformation that is specifically built for Android devices is the project Gplad (Graphical Programming Language for Android Devices) \cite{gplad}. It is a domain-specific language that allows code generation in a block-based programming interface, to obtain solutions in various common programming languages, including Java. It's aim is provide a simple programming environment without necessarily needing advanced coding knowledge.

The first stage in our development is to analyze the DSL anatomy of Android Intents and the related sections, this DSL will then be developed into an EMF Ecore Model. Once the Model has been created, a selection of Android Intents will be chosen as test subjects and will be built using as Dynamic Instances through the EMF tools. This relatively small subset of Intents will be chosen for their common usage and variance, and will allow us to revise the model and ensure it is capable of handling the different variety of Intents possible.

Once our Model has been revised to an extent that we believe it is suitable for the majority of available Intents, we will then develop our Xtext grammar using the generated grammar that Xtext provides as a base. The grammar will be revised to simplify the development in the concrete syntax, and our previous selection of Intents will be built in this Xtext grammar.

The next step in development is to build the Eclipse plug-in that reads our models and generates the Eclipse AST nodes required to provide a Model-to-Model transformation. The final stage is to thoroughly test our plug-in and run our evaluation.

This planned methodology enables us to revise our DSL and model several times through development, and ensure each stage is completed successfully, but these additional processes and iterations, will increase development time.

The work we have done over the course of this project has concluded with a final plug-in for which the scope of functionality can be further expanded, with our current code base providing the basis for further development into areas such as:

\begin{itemize}
\item Code generation to a greater extent. This could include generation of code for broadcast receivers and Intent callback methods.
\item Automatic code completion.
\item Extracting Intent calls from existing code.
\item Acquiring the data for Intent code generation, from an external database.
\item Adding permissions to the manifest file automatically, if the data we have concerning a specific Intent indicates that it is required.
\end{itemize}

This paper is organized as follows. In Section \ref{background} we present the Android Intent syntax and make an overview of the tools we use in the project. In Section \ref{realisation} we present the step-by-step solution for the Intent code generation. In Section \ref{evaluation} we evaluate our solution, and then discuss its results and the threats to validity of our solution in Section \ref{threatstovalidity}. In section \ref{usecases} we present some use cases. In section \ref{relatedwork} we present some of the found related work. In Section \ref{Discussion}, we suggest ideas for future projects, and finally we conclude our research in Section \ref{conclusion}.